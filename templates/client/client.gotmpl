// Code generated by go-swagger; DO NOT EDIT.

// :Form3: Testing!


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .Name }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"
  "github.com/go-openapi/errors"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/runtime"
  "github.com/go-openapi/validate"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New creates a new {{ humanize .Name }} API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, defaults client.Defaults) *Client {
  return &Client{transport: transport, formats: formats, Defaults: defaults}
}

/*
Client {{ if .Summary }}{{ .Summary }}{{ if .Description }}

{{ blockcomment .Description }}{{ end }}{{ else if .Description}}{{ blockcomment .Description }}{{ else }}for {{ humanize .Name }} API{{ end }}
*/
type Client struct {
  transport runtime.ClientTransport
  formats strfmt.Registry
  Defaults client.Defaults
}


// range of operations
{{ range .Operations }}

/*
{{ if .Description}}{{ comment .Description }}{{ else }}{{ humanize .Name }} API{{ end }}
*/
func (a *{{ pascalize .Name }}Request) Do() {{ if .SuccessResponse }}({{ range .SuccessResponses }}*{{ pascalize .Name }}, {{ end }}{{ end }}error{{ if .SuccessResponse }}){{ end }} {
        {{ $length := len .SuccessResponses }}

         {{ if .SuccessResponse }}result{{else}}_{{ end }}, err := a.transport.Submit(&runtime.ClientOperation{
           ID: {{ printf "%q" .Name }},
           Method: {{ printf "%q" .Method }},
           PathPattern: {{ printf "%q" .Path }},
           ProducesMediaTypes: {{ printf "%#v" .ProducesMediaTypes }},
           ConsumesMediaTypes: {{ printf "%#v" .ConsumesMediaTypes }},
           Schemes: {{ printf "%#v" .Schemes }},
           Params: a,
           {{ if .HasStreamingResponse }} // TODO - pass streaming response to reader.  {{ end }}
           Reader: &{{ pascalize .Name }}Reader{formats: a.formats},{{ if .Authorized }}
           //AuthInfo: authInfo,{{ end}}
           Context: a.Context,
           Client: a.HTTPClient,
         })
         if err != nil {
           return {{ if .SuccessResponse }}{{ padSurround "nil" "nil" 0 $length }}, {{ end }}err
         }
         {{ if .SuccessResponse }}{{ if eq $length 1 }}return result.(*{{ pascalize .SuccessResponse.Name }}), nil{{ else }}switch value := result.(type) { {{ range $i, $v := .SuccessResponses }}
           case *{{ pascalize $v.Name }}:
             return {{ padSurround "value" "nil" $i $length }}, nil{{ end }} }
         return {{ padSurround "nil" "nil" 0 $length }}, nil{{ end }}
         {{ else }}return nil{{ end }}
}

func (a *{{ pascalize .Name }}Request) MustDo() {{ if .SuccessResponse }}({{ range .SuccessResponses }}*{{ pascalize .Name }} {{ end }}{{ end }}{{ if .SuccessResponse }}){{ end }} {
    r, err := a.Do()
    if err != nil {
        panic(err)
    }
    return r
}

func (a *{{ pascalize .Name }}Request) WithTimeout(d time.Duration) *{{ pascalize .Name }}Request {
    deadlineTime := time.Now().Add(d)
    a.Context, _ = context.WithDeadline(a.Context, deadlineTime)
    a.Context, _ = context.WithTimeout(a.Context, d)
    return a
}

{{ end }}

/////////

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
  a.transport = transport
}
