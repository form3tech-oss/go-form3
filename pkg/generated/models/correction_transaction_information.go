// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"log"
	"strconv"

	"github.com/form3tech-oss/go-form3/v7/pkg/client"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CorrectionTransactionInformation References a transaction initiated to fix the case under investigation.
// swagger:model CorrectionTransactionInformation
type CorrectionTransactionInformation struct {

	// Amount of money moved between the instructing agent and the instructed agent.
	// Pattern: ^[0-9.]{0,14}$
	Amount string `json:"amount,omitempty"`

	// Currency of the transaction amount. Currency code as defined in [ISO 4217](https://www.iso.org/iso/home/standards/currency_codes.htm)
	// Max Length: 3
	// Min Length: 3
	Currency string `json:"currency,omitempty"`

	// Unique identification, as assigned by the initiating party, to unambiguously identify the transaction. This identification is passed on, unchanged, throughout the entire end-to-end chain.
	// Max Length: 35
	EndToEndReference string `json:"end_to_end_reference,omitempty"`

	// Unique identification, as assigned by an instructing party for an instructed party, to unambiguously identify the instruction.
	// Max Length: 35
	InstructionID string `json:"instruction_id,omitempty"`

	// Date on which the amount of money ceases to be available to the agent that owes it and when the amount of money becomes available to the agent to which it is due.
	// Format: date
	ProcessingDate *strfmt.Date `json:"processing_date,omitempty"`

	// Reference for the corrective payment for this query case.
	References []*QueryReference `json:"references,omitempty"`

	// Unique identification, as assigned by the first instructing agent, to unambiguously identify the transaction that is passed on, unchanged, throughout the entire interbank chain.
	// Max Length: 35
	SchemeTransactionID string `json:"scheme_transaction_id,omitempty"`

	// The scheme-specific unique transaction ID to unambiguously identify the message. Populated by the scheme.
	// Max Length: 35
	UniqueSchemeID string `json:"unique_scheme_id,omitempty"`
}

func CorrectionTransactionInformationWithDefaults(defaults client.Defaults) *CorrectionTransactionInformation {
	return &CorrectionTransactionInformation{

		Amount: defaults.GetString("CorrectionTransactionInformation", "amount"),

		Currency: defaults.GetString("CorrectionTransactionInformation", "currency"),

		EndToEndReference: defaults.GetString("CorrectionTransactionInformation", "end_to_end_reference"),

		InstructionID: defaults.GetString("CorrectionTransactionInformation", "instruction_id"),

		ProcessingDate: defaults.GetStrfmtDatePtr("CorrectionTransactionInformation", "processing_date"),

		References: make([]*QueryReference, 0),

		SchemeTransactionID: defaults.GetString("CorrectionTransactionInformation", "scheme_transaction_id"),

		UniqueSchemeID: defaults.GetString("CorrectionTransactionInformation", "unique_scheme_id"),
	}
}

func (m *CorrectionTransactionInformation) WithAmount(amount string) *CorrectionTransactionInformation {

	m.Amount = amount

	return m
}

func (m *CorrectionTransactionInformation) WithCurrency(currency string) *CorrectionTransactionInformation {

	m.Currency = currency

	return m
}

func (m *CorrectionTransactionInformation) WithEndToEndReference(endToEndReference string) *CorrectionTransactionInformation {

	m.EndToEndReference = endToEndReference

	return m
}

func (m *CorrectionTransactionInformation) WithInstructionID(instructionID string) *CorrectionTransactionInformation {

	m.InstructionID = instructionID

	return m
}

func (m *CorrectionTransactionInformation) WithProcessingDate(processingDate strfmt.Date) *CorrectionTransactionInformation {

	m.ProcessingDate = &processingDate

	return m
}

func (m *CorrectionTransactionInformation) WithoutProcessingDate() *CorrectionTransactionInformation {
	m.ProcessingDate = nil
	return m
}

func (m *CorrectionTransactionInformation) WithReferences(references []*QueryReference) *CorrectionTransactionInformation {

	m.References = references

	return m
}

func (m *CorrectionTransactionInformation) WithSchemeTransactionID(schemeTransactionID string) *CorrectionTransactionInformation {

	m.SchemeTransactionID = schemeTransactionID

	return m
}

func (m *CorrectionTransactionInformation) WithUniqueSchemeID(uniqueSchemeID string) *CorrectionTransactionInformation {

	m.UniqueSchemeID = uniqueSchemeID

	return m
}

// Validate validates this correction transaction information
func (m *CorrectionTransactionInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndToEndReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInstructionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReferences(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemeTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUniqueSchemeID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CorrectionTransactionInformation) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.Amount) { // not required
		return nil
	}

	if err := validate.Pattern("amount", "body", string(m.Amount), `^[0-9.]{0,14}$`); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if err := validate.MinLength("currency", "body", string(m.Currency), 3); err != nil {
		return err
	}

	if err := validate.MaxLength("currency", "body", string(m.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateEndToEndReference(formats strfmt.Registry) error {

	if swag.IsZero(m.EndToEndReference) { // not required
		return nil
	}

	if err := validate.MaxLength("end_to_end_reference", "body", string(m.EndToEndReference), 35); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateInstructionID(formats strfmt.Registry) error {

	if swag.IsZero(m.InstructionID) { // not required
		return nil
	}

	if err := validate.MaxLength("instruction_id", "body", string(m.InstructionID), 35); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateProcessingDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessingDate) { // not required
		return nil
	}

	if err := validate.FormatOf("processing_date", "body", "date", m.ProcessingDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateReferences(formats strfmt.Registry) error {

	if swag.IsZero(m.References) { // not required
		return nil
	}

	for i := 0; i < len(m.References); i++ {
		if swag.IsZero(m.References[i]) { // not required
			continue
		}

		if m.References[i] != nil {
			if err := m.References[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("references" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CorrectionTransactionInformation) validateSchemeTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(m.SchemeTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("scheme_transaction_id", "body", string(m.SchemeTransactionID), 35); err != nil {
		return err
	}

	return nil
}

func (m *CorrectionTransactionInformation) validateUniqueSchemeID(formats strfmt.Registry) error {

	if swag.IsZero(m.UniqueSchemeID) { // not required
		return nil
	}

	if err := validate.MaxLength("unique_scheme_id", "body", string(m.UniqueSchemeID), 35); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CorrectionTransactionInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CorrectionTransactionInformation) UnmarshalBinary(b []byte) error {
	var res CorrectionTransactionInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
func (m *CorrectionTransactionInformation) Json() string {
	json, err := json.MarshalIndent(m, "  ", "  ")
	if err != nil {
		log.Fatal(err)
	}
	return string(json)
}
