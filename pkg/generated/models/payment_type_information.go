// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"log"

	"github.com/form3tech-oss/go-form3/v7/pkg/client"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PaymentTypeInformation Set of elements used to further specify the type of transaction.
// swagger:model PaymentTypeInformation
type PaymentTypeInformation struct {

	// Amount of money to be moved between the debtor and creditor, before deduction of charges.
	// Pattern: ^[0-9.]{0,14}$
	Amount string `json:"amount,omitempty"`

	// Specifies the high level purpose of the instruction based on a set of pre-defined categories.
	// Max Length: 35
	CategoryPurpose string `json:"category_purpose,omitempty"`

	// Currency of the transaction amount. Currency code as defined in [ISO 4217](https://www.iso.org/iso/home/standards/currency_codes.htm)
	// Max Length: 3
	// Min Length: 3
	Currency string `json:"currency,omitempty"`

	// Underlying reason for the payment transaction. Defined in external code list (4 char) or proprietary code (35 char)
	// Max Length: 35
	// Min Length: 4
	PaymentPurpose string `json:"payment_purpose,omitempty"`

	// Date on which the amount of money ceases to be available to the agent that owes it and when the amount of money becomes available to the agent to which it is due.
	// Format: date
	ProcessingDate *strfmt.Date `json:"processing_date,omitempty"`

	// Unstructured information supplied to enable the matching/reconciliation of an entry with the items that the payment is intended to settle.
	// Max Length: 140
	RemittanceInformation string `json:"remittance_information,omitempty"`

	// Specifies a local instrument to further qualify the level of service.
	// Max Length: 35
	SchemePaymentSubType string `json:"scheme_payment_sub_type,omitempty"`

	// Specifies a pre-agreed level of service as published in an external code list (4 char) or a proprietary code (35 char).
	// Max Length: 35
	SchemePaymentType string `json:"scheme_payment_type,omitempty"`
}

func PaymentTypeInformationWithDefaults(defaults client.Defaults) *PaymentTypeInformation {
	return &PaymentTypeInformation{

		Amount: defaults.GetString("PaymentTypeInformation", "amount"),

		CategoryPurpose: defaults.GetString("PaymentTypeInformation", "category_purpose"),

		Currency: defaults.GetString("PaymentTypeInformation", "currency"),

		PaymentPurpose: defaults.GetString("PaymentTypeInformation", "payment_purpose"),

		ProcessingDate: defaults.GetStrfmtDatePtr("PaymentTypeInformation", "processing_date"),

		RemittanceInformation: defaults.GetString("PaymentTypeInformation", "remittance_information"),

		SchemePaymentSubType: defaults.GetString("PaymentTypeInformation", "scheme_payment_sub_type"),

		SchemePaymentType: defaults.GetString("PaymentTypeInformation", "scheme_payment_type"),
	}
}

func (m *PaymentTypeInformation) WithAmount(amount string) *PaymentTypeInformation {

	m.Amount = amount

	return m
}

func (m *PaymentTypeInformation) WithCategoryPurpose(categoryPurpose string) *PaymentTypeInformation {

	m.CategoryPurpose = categoryPurpose

	return m
}

func (m *PaymentTypeInformation) WithCurrency(currency string) *PaymentTypeInformation {

	m.Currency = currency

	return m
}

func (m *PaymentTypeInformation) WithPaymentPurpose(paymentPurpose string) *PaymentTypeInformation {

	m.PaymentPurpose = paymentPurpose

	return m
}

func (m *PaymentTypeInformation) WithProcessingDate(processingDate strfmt.Date) *PaymentTypeInformation {

	m.ProcessingDate = &processingDate

	return m
}

func (m *PaymentTypeInformation) WithoutProcessingDate() *PaymentTypeInformation {
	m.ProcessingDate = nil
	return m
}

func (m *PaymentTypeInformation) WithRemittanceInformation(remittanceInformation string) *PaymentTypeInformation {

	m.RemittanceInformation = remittanceInformation

	return m
}

func (m *PaymentTypeInformation) WithSchemePaymentSubType(schemePaymentSubType string) *PaymentTypeInformation {

	m.SchemePaymentSubType = schemePaymentSubType

	return m
}

func (m *PaymentTypeInformation) WithSchemePaymentType(schemePaymentType string) *PaymentTypeInformation {

	m.SchemePaymentType = schemePaymentType

	return m
}

// Validate validates this payment type information
func (m *PaymentTypeInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategoryPurpose(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentPurpose(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProcessingDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemittanceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemePaymentSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSchemePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PaymentTypeInformation) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(m.Amount) { // not required
		return nil
	}

	if err := validate.Pattern("amount", "body", string(m.Amount), `^[0-9.]{0,14}$`); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateCategoryPurpose(formats strfmt.Registry) error {

	if swag.IsZero(m.CategoryPurpose) { // not required
		return nil
	}

	if err := validate.MaxLength("category_purpose", "body", string(m.CategoryPurpose), 35); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if err := validate.MinLength("currency", "body", string(m.Currency), 3); err != nil {
		return err
	}

	if err := validate.MaxLength("currency", "body", string(m.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validatePaymentPurpose(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentPurpose) { // not required
		return nil
	}

	if err := validate.MinLength("payment_purpose", "body", string(m.PaymentPurpose), 4); err != nil {
		return err
	}

	if err := validate.MaxLength("payment_purpose", "body", string(m.PaymentPurpose), 35); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateProcessingDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ProcessingDate) { // not required
		return nil
	}

	if err := validate.FormatOf("processing_date", "body", "date", m.ProcessingDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateRemittanceInformation(formats strfmt.Registry) error {

	if swag.IsZero(m.RemittanceInformation) { // not required
		return nil
	}

	if err := validate.MaxLength("remittance_information", "body", string(m.RemittanceInformation), 140); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateSchemePaymentSubType(formats strfmt.Registry) error {

	if swag.IsZero(m.SchemePaymentSubType) { // not required
		return nil
	}

	if err := validate.MaxLength("scheme_payment_sub_type", "body", string(m.SchemePaymentSubType), 35); err != nil {
		return err
	}

	return nil
}

func (m *PaymentTypeInformation) validateSchemePaymentType(formats strfmt.Registry) error {

	if swag.IsZero(m.SchemePaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("scheme_payment_type", "body", string(m.SchemePaymentType), 35); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PaymentTypeInformation) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PaymentTypeInformation) UnmarshalBinary(b []byte) error {
	var res PaymentTypeInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
func (m *PaymentTypeInformation) Json() string {
	json, err := json.MarshalIndent(m, "  ", "  ")
	if err != nil {
		log.Fatal(err)
	}
	return string(json)
}
