// Code generated by go-swagger; DO NOT EDIT.

package {{ .Package }}

import (
  "context"
  "net/http"

  "github.com/go-openapi/runtime"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/errors"
  "github.com/go-openapi/validate"
  cr "github.com/go-openapi/runtime/client"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
)

// Client.{{ pascalize .Name }} creates a new {{ pascalize .Name }}Request object
// with the default values initialized.
func (c *Client) {{ pascalize .Name }}() *{{ pascalize .Name }}Request {
{{ if .Params }}var (
  {{ range .Params }}{{ if .HasDefault }}{{ if not .IsFileParam }}{{ varname .ID}}Default = {{ if .IsPrimitive}}{{.GoType}}({{ end}}{{ printf "%#v" .Default }}{{ if .IsPrimitive }}){{ end }}
  {{ end }}{{ end }}{{end}}
  ){{ end }}
  return &{{ pascalize .Name}}Request{
  {{ range .Params }}
      {{ if .IsStream }}
        // TODO - stream {{ pascalize .Name}}: {{ .GoType }}
      {{ else if .HasDefault }}
          {{ pascalize .Name}}: &{{ varname .ID}}Default,

      {{ else if .IsAliased }}
          // TODO {{ pascalize .Name}}: {{ .GoType }},
        {{ else if .IsArray }}
          {{ pascalize .Name}}: make({{ .GoType }}, 0),
        {{ else if .IsComplexObject }}
          {{ dropPackage .GoType}}: {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (or .IsNullable  ) }}{{ end }}{{ .GoType }}WithDefaults(c.Defaults),
        {{ else }}
          {{ pascalize .Name}}: c.Defaults.Get{{pascalize .GoType}}{{ if .IsNullable }}Ptr{{ end }}{{ if .IsArray }}Array{{ end }}("{{$.Name}}","{{.Name}}"),
        {{ end }}
  {{ end }}
    {{ camelize .TimeoutName }}: cr.DefaultTimeout,

	transport: c.transport,
	formats: c.formats,
  }
}

type {{ pascalize .Name }}Request struct {
  {{ range .Params }}
      /*{{ pascalize .Name }}{{if .Description }}      {{ blockcomment .Description }}      {{ end }}*/
      {{ if eq "body" .Location }}
           {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) (or .IsNullable  ) }}*{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}runtime.NamedReadCloser{{end}}
      {{ else }}
          {{ pascalize .ID }} {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsInterface) (not .IsStream) (or .IsNullable  ) }}*{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}runtime.NamedReadCloser{{end}}
      {{ end }}
  {{ end }}

  {{ camelize .TimeoutName }} time.Duration
  Context context.Context
  HTTPClient *http.Client

	transport runtime.ClientTransport
	formats   strfmt.Registry
}

func ({{ .ReceiverName }} *{{ pascalize .Name }}Request) FromJson(j string) *{{ pascalize .Name }}Request {
    {{ range .Params }}
      {{ if and (eq "body" .Location) (not .IsStream) }}
        var m {{ .GoType }}
      	if err := json.Unmarshal([]byte(j), &m); err != nil {
      		log.Fatal(err)
      	}

        {{ .ReceiverName }}.{{ dropPackage .GoType }} = &m
      {{ end }}
  {{ end }}

    return {{ .ReceiverName }}
}


{{ range .Params }}
    {{ if not .IsStream }}
    func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Request) With{{ pascalize .ID }}({{ varname .Name  }} {{ if and (not .IsArray) (not .IsMap) (not .HasDiscriminator) (not .IsStream) }}{{ end }}{{ if not .IsFileParam }}{{ .GoType }}{{ else }}runtime.NamedReadCloser{{ end }}) *{{ pascalize $.Name }}Request {

          {{ if and (eq "body" .Location) (not .IsStream) }}
          {{ $.ReceiverName }}.{{ dropPackage .GoType }} = &{{ varname .Name }}
        {{ else if and .IsNullable (not .IsArray)}}
          {{ $.ReceiverName }}.{{ pascalize .ID }} = &{{ varname .Name }}
        {{ else }}
          {{ $.ReceiverName }}.{{ pascalize .ID }} = {{ varname .Name  }}
        {{ end }}
      return {{ .ReceiverName }}
    }

    {{if .IsNullable}}
        func ({{ $.ReceiverName }} *{{ pascalize $.Name }}Request) Without{{ pascalize .ID }}() *{{ pascalize $.Name }}Request {
            {{ if eq "body" .Location }}
                {{ $.ReceiverName }}.{{ dropPackage .GoType }} = &{{ .GoType }}{}
          {{else}}
               {{ $.ReceiverName }}.{{ pascalize .ID }} = nil
           {{end}}
           return {{ .ReceiverName }}
         }
    {{ end }}
    {{ end }}
{{ end }}



//////////////////
// WithContext adds the context to the {{ humanize .Name }} Request
func ({{ .ReceiverName }} *{{ pascalize .Name }}Request) WithContext(ctx context.Context) *{{ pascalize .Name }}Request {
  {{ .ReceiverName }}.Context = ctx
  return {{ .ReceiverName }}
}

// WithHTTPClient adds the HTTPClient to the {{ humanize .Name }} Request
func ({{ .ReceiverName }} *{{ pascalize .Name }}Request) WithHTTPClient(client *http.Client) *{{ pascalize .Name }}Request {
  {{ .ReceiverName }}.HTTPClient = client
  return {{ .ReceiverName }}
}

// WriteToRequest writes these Request to a swagger request
func ({{ .ReceiverName }} *{{ pascalize .Name }}Request) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {

  if err := r.SetTimeout({{ .ReceiverName }}.{{ camelize .TimeoutName }}); err != nil {
    return err
  }
  var res []error
  {{range .Params}}

  {{if not (or .IsArray .IsMap .IsBodyParam) }}
  {{ if and .IsNullable (not .AllowEmptyValue) }}if {{ .ValueExpression }} != nil { {{ end}}
  {{ if .IsQueryParam }}
      // query param {{ .Name }}
      {{ if .IsNullable }}var qr{{ pascalize .Name }} {{ .GoType }}
      if {{ .ValueExpression }} != nil {
        qr{{ pascalize .Name }} = *{{ .ValueExpression }}
      }{{ else }}qr{{ pascalize .Name }} := {{ .ValueExpression }}{{ end}}
      q{{ pascalize .Name}} := {{ if .Formatter }}{{ .Formatter }}(qr{{ pascalize .Name }}){{ else }}qr{{ pascalize .Name }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}{{ if not .AllowEmptyValue }}
      if q{{ pascalize .Name }} != "" { {{ end }}
      if err := r.SetQueryParam({{ printf "%q" .Name }}, q{{ pascalize .Name }}); err != nil {
        return err
      }
        {{ if not .AllowEmptyValue }}}{{ end }}
  {{ else if .IsPathParam }}
      // path param {{ .Name }}
      if err := r.SetPathParam({{ printf "%q" .Name }}, {{ if .Formatter }}{{ .Formatter }}({{ if .IsNullable }}*{{end}}{{ .ValueExpression }}){{ else }}{{ if and (not .IsCustomFormatter) .IsNullable }}*{{end}}{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}); err != nil {
        return err
      }
  {{ else if .IsHeaderParam }}
      // header param {{ .Name }}
      if err := r.SetHeaderParam({{ printf "%q" .Name }}, {{ if .Formatter }}{{ .Formatter }}({{ if .IsNullable }}*{{end}}{{ .ValueExpression }}){{ else }}{{ if and (not .IsCustomFormatter) .IsNullable }}*{{end}}{{ .ValueExpression }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}); err != nil {
        return err
      }
  {{ else if .IsFormParam }}
      {{ if .IsFileParam }}
          {{ if .IsNullable}}
          if {{ .ValueExpression }} != nil {
          {{end}}
            // form file param {{ .Name }}
            if err := r.SetFileParam({{ printf "%q" .Name }}, {{ .ValueExpression }}); err != nil {
              return err
            }
          {{ if .IsNullable}}
          }
      {{ end }}
  {{ else }}
      // form param {{ .Name }}
      {{ if .IsNullable }}var fr{{ pascalize .Name }} {{ .GoType }}
      if {{ .ValueExpression }} != nil {
        fr{{ pascalize .Name }} = *{{ .ValueExpression }}
      }{{ else }}fr{{ pascalize .Name }} := {{ .ValueExpression }}{{ end}}
      f{{ pascalize .Name}} := {{ if .Formatter }}{{ .Formatter }}(fr{{ pascalize .Name }}){{ else }}fr{{ pascalize .Name }}{{ if .IsCustomFormatter }}.String(){{end}}{{end}}{{ if not .AllowEmptyValue }}
      if f{{ pascalize .Name }} != "" { {{ end }}
      if err := r.SetFormParam({{ printf "%q" .Name }}, f{{ pascalize .Name }}); err != nil {
        return err
      }
      {{ if not .AllowEmptyValue }}}{{ end }}
      {{ end }}
  {{ end }}
  {{ if and .IsNullable (not .AllowEmptyValue) }}}{{end}}
  {{else if .IsArray }}
  {{ if not .IsBodyParam }}{{ if .Child }}{{ if or .Child.Formatter .Child.IsCustomFormatter }}var values{{ pascalize .Name }} []string
  for _, v := range {{ if and (not .IsArray) (not .IsMap) (not .IsStream) (.IsNullable) }}*{{end}}{{ .ValueExpression }} {
    values{{ pascalize .Name }} = append(values{{ pascalize .Name }}, {{ .Child.Formatter }}{{ if .Child.Formatter }}({{ end }}v{{ if .Child.IsCustomFormatter }}.String(){{ end }}{{ if .Child.Formatter }}){{ end }})
  }
  {{ else }}values{{ pascalize .Name }} := {{ if and (not .IsArray) (not .IsStream) (not .IsMap) (.IsNullable) }}*{{end}}{{ .ValueExpression }}{{ end }}
  {{ else }}values{{ pascalize .Name }} := {{ if and (not .IsArray) (not .IsStream) (not .IsMap) (.IsNullable) }}*{{end}}{{ .ValueExpression }}{{ end }}
  joined{{ pascalize .Name}} := swag.JoinByFormat(values{{ pascalize .Name }}, "{{.CollectionFormat}}")
  {{ if .IsQueryParam }}// query array param {{ .Name }}
  if err := r.SetQueryParam({{ printf "%q" .Name }}, joined{{ pascalize .Name }}...); err != nil {
    return err
  }
  {{ else if and .IsFormParam }}// form array param {{ .Name }}
  if err := r.SetFormParam({{ printf "%q" .Name }}, joined{{ pascalize .Name }}...); err != nil {
    return err
  }
  {{ else if and .IsPathParam }}// path array param {{ .Name }}
  // SetPathParam does not support variadric arguments, since we used JoinByFormat
  // we can send the first item in the array as it's all the items of the previous
  // array joined together
  if len(joined{{ pascalize .Name }}) > 0 {
     if err := r.SetPathParam({{ printf "%q" .Name }}, joined{{ pascalize .Name }}[0]); err != nil {
      return err
    }
  }
  {{ end }}{{ end }}

  {{ end }}

  {{if .IsBodyParam}}
  // ISBODYPARAM
    {{ if or .Schema.IsInterface .Schema.IsStream (and .Schema.IsArray .Child) (and .Schema.IsMap .Child) (and .Schema.IsNullable (not .HasDiscriminator)) }} if {{ .ReceiverName }}.{{ dropPackage .GoType }} != nil { {{end}}
    if err := r.SetBodyParam({{ .ReceiverName }}.{{ dropPackage .GoType }}); err != nil {
      return err
    }
  {{ if or .Schema.IsInterface .Schema.IsStream (and .Schema.IsArray .Child) (and .Schema.IsMap .Child) (and .Schema.IsNullable (not .HasDiscriminator)) }} } {{end}}
  {{end}}

  {{end}}
  if len(res) > 0 {
    return errors.CompositeValidationError(res...)
  }
  return nil
}
